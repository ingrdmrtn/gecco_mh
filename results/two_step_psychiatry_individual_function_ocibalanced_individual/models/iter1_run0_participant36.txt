Here are three new cognitive models exploring different mechanisms for learning and decision-making in the two-step task. These models introduce distinct parameter combinations not yet tested (e.g., separate learning rates, eligibility traces, and outcome-specific stickiness).

### Model 1: Hybrid Learner with Separate Learning Rates for Reward and No-Reward
This model hypothesizes that the participant might update their beliefs differently when they receive a reward (positive reinforcement) versus when they receive nothing (omission or punishment). This asymmetry is often observed in clinical populations or specific cognitive styles.

```python
import numpy as np

def cognitive_model1(action_1, state, action_2, reward, model_parameters):
    """
    Hybrid Learner with Asymmetric Learning Rates.
    Distinguishes between learning from positive outcomes (alpha_pos) and 
    neutral/negative outcomes (alpha_neg).

    Parameters:
    alpha_pos: [0,1] - Learning rate for rewarded trials (reward == 1).
    alpha_neg: [0,1] - Learning rate for unrewarded trials (reward == 0).
    beta: [0,10] - Inverse temperature.
    w: [0,1] - MB/MF mixing weight.
    """
    alpha_pos, alpha_neg, beta, w = model_parameters
    n_trials = len(action_1)
  
    transition_matrix = np.array([[0.7, 0.3], [0.3, 0.7]])
    p_choice_1 = np.zeros(n_trials)
    p_choice_2 = np.zeros(n_trials)
    
    q_stage1_mf = np.zeros(2)
    q_stage2_mf = np.zeros((2, 2))

    for trial in range(n_trials):

        # --- Stage 1 Policy ---
        max_q_stage2 = np.max(q_stage2_mf, axis=1)
        q_stage1_mb = transition_matrix @ max_q_stage2
        
        q_net = w * q_stage1_mb + (1 - w) * q_stage1_mf
        
        exp_q1 = np.exp(beta * q_net)
        probs_1 = exp_q1 / np.sum(exp_q1)
        p_choice_1[trial] = probs_1[action_1[trial]]

        state_idx = state[trial]
        chosen_a1 = action_1[trial]
        chosen_a2 = action_2[trial]
        r = reward[trial]

        # --- Stage 2 Policy ---
        exp_q2 = np.exp(beta * q_stage2_mf[state_idx])
        probs_2 = exp_q2 / np.sum(exp_q2)
        p_choice_2[trial] = probs_2[chosen_a2]

        # Determine which learning rate to use
        current_alpha = alpha_pos if r == 1 else alpha_neg

        # --- Updating ---
        # Update Stage 1 MF value (SARSA-style update using Stage 2 Q-value)
        delta_stage1 = q_stage2_mf[state_idx, chosen_a2] - q_stage1_mf[chosen_a1]
        q_stage1_mf[chosen_a1] += current_alpha * delta_stage1
        
        # Update Stage 2 MF value
        delta_stage2 = r - q_stage2_mf[state_idx, chosen_a2]
        q_stage2_mf[state_idx, chosen_a2] += current_alpha * delta_stage2
        

    eps = 1e-10
    log_loss = -(np.sum(np.log(p_choice_1 + eps)) + np.sum(np.log(p_choice_2 + eps)))
    return log_loss
```

### Model 2: Model-Free Learner with Eligibility Traces (TD(lambda))
This model removes the Model-Based component entirely (`w=0`) but introduces an eligibility trace parameter (`lambda`). This allows the Stage 2 reward to directly influence the Stage 1 choice without needing the intermediate step of updating Stage 2 values first. This tests if the participant is a sophisticated Model-Free learner rather than a hybrid learner.

```python
import numpy as np

def cognitive_model2(action_1, state, action_2, reward, model_parameters):
    """
    Pure Model-Free Learner with Eligibility Traces (TD(lambda)).
    Allows the reward at the second stage to directly update the first stage choice 
    via an eligibility trace, bypassing the need for a Model-Based planner.

    Parameters:
    learning_rate: [0,1] - Update rate.
    beta: [0,10] - Inverse temperature.
    lam: [0,1] - Eligibility trace decay parameter (lambda). 
                 0 = TD(0) (update only from next state), 
                 1 = Monte Carlo (update fully from outcome).
    """
    learning_rate, beta, lam = model_parameters
    n_trials = len(action_1)
  
    # No transition matrix needed for pure MF
    p_choice_1 = np.zeros(n_trials)
    p_choice_2 = np.zeros(n_trials)
    
    q_stage1_mf = np.zeros(2)
    q_stage2_mf = np.zeros((2, 2))

    for trial in range(n_trials):

        # --- Stage 1 Policy ---
        # Pure MF Q-values for stage 1
        exp_q1 = np.exp(beta * q_stage1_mf)
        probs_1 = exp_q1 / np.sum(exp_q1)
        p_choice_1[trial] = probs_1[action_1[trial]]

        state_idx = state[trial]
        chosen_a1 = action_1[trial]
        chosen_a2 = action_2[trial]
        r = reward[trial]

        # --- Stage 2 Policy ---
        exp_q2 = np.exp(beta * q_stage2_mf[state_idx])
        probs_2 = exp_q2 / np.sum(exp_q2)
        p_choice_2[trial] = probs_2[chosen_a2]

        # --- Updating with Eligibility Trace ---
        
        # 1. Prediction error at stage 1: (Q_stage2 - Q_stage1)
        delta_1 = q_stage2_mf[state_idx, chosen_a2] - q_stage1_mf[chosen_a1]
        
        # Update Stage 1 based on transition to Stage 2
        q_stage1_mf[chosen_a1] += learning_rate * delta_1
        
        # 2. Prediction error at stage 2: (Reward - Q_stage2)
        delta_2 = r - q_stage2_mf[state_idx, chosen_a2]
        
        # Update Stage 2
        q_stage2_mf[state_idx, chosen_a2] += learning_rate * delta_2
        
        # 3. Apply Eligibility Trace:
        # The Stage 1 action is also updated by the Stage 2 prediction error,
        # scaled by lambda. This connects the final reward back to the first choice.
        q_stage1_mf[chosen_a1] += learning_rate * lam * delta_2

    eps = 1e-10
    log_loss = -(np.sum(np.log(p_choice_1 + eps)) + np.sum(np.log(p_choice_2 + eps)))
    return log_loss
```

### Model 3: Hybrid Learner with "Win-Stay, Lose-Switch" Stickiness
Unlike simple choice perseveration (repeating the last choice regardless of outcome), this model implements a more nuanced heuristic often seen in human data: "Win-Stay, Lose-Switch" (WSLS) applied as a bias on top of the hybrid reinforcement learning. It adds a bonus to the previous action only if it was rewarded.

```python
import numpy as np

def cognitive_model3(action_1, state, action_2, reward, model_parameters):
    """
    Hybrid Learner with Outcome-Dependent Stickiness (Win-Stay).
    Adds a bias to repeat the previous Stage 1 choice, but ONLY if 
    the previous trial resulted in a reward.

    Parameters:
    learning_rate: [0,1] - Update rate.
    beta: [0,10] - Inverse temperature.
    w: [0,1] - MB/MF mixing weight.
    win_stickiness: [0,5] - Bonus added to the previous action if reward was received.
    """
    learning_rate, beta, w, win_stickiness = model_parameters
    n_trials = len(action_1)
  
    transition_matrix = np.array([[0.7, 0.3], [0.3, 0.7]])
    p_choice_1 = np.zeros(n_trials)
    p_choice_2 = np.zeros(n_trials)
    
    q_stage1_mf = np.zeros(2)
    q_stage2_mf = np.zeros((2, 2))

    last_choice = -1
    last_reward = 0

    for trial in range(n_trials):

        # --- Stage 1 Policy ---
        max_q_stage2 = np.max(q_stage2_mf, axis=1)
        q_stage1_mb = transition_matrix @ max_q_stage2
        
        q_net = w * q_stage1_mb + (1 - w) * q_stage1_mf

        # Apply Win-Stay Stickiness
        if last_choice != -1 and last_reward == 1:
            q_net[last_choice] += win_stickiness

        exp_q1 = np.exp(beta * q_net)
        probs_1 = exp_q1 / np.sum(exp_q1)
        p_choice_1[trial] = probs_1[action_1[trial]]

        # Record history for next trial
        last_choice = action_1[trial]
        state_idx = state[trial]
        chosen_a2 = action_2[trial]
        r = reward[trial]
        last_reward = r

        # --- Stage 2 Policy ---
        exp_q2 = np.exp(beta * q_stage2_mf[state_idx])
        probs_2 = exp_q2 / np.sum(exp_q2)
        p_choice_2[trial] = probs_2[chosen_a2]

        # --- Updating ---
        delta_stage1 = q_stage2_mf[state_idx, chosen_a2] - q_stage1_mf[action_1[trial]]
        q_stage1_mf[action_1[trial]] += learning_rate * delta_stage1
        
        delta_stage2 = r - q_stage2_mf[state_idx, chosen_a2]
        q_stage2_mf[state_idx, chosen_a2] += learning_rate * delta_stage2
        

    eps = 1e-10
    log_loss = -(np.sum(np.log(p_choice_1 + eps)) + np.sum(np.log(p_choice_2 + eps)))
    return log_loss
```