```python
import numpy as np
from abc import ABC, abstractmethod

# --- Provided CognitiveModelBase and ParticipantModel3 classes ---
# (These are included for completeness but would typically be defined elsewhere
# and imported, or assumed to be in the same scope.)

class CognitiveModelBase(ABC):
    """
    Base class for cognitive models in a two-step task.
    
    Override methods to implement participant-specific cognitive strategies.
    """

    def __init__(self, n_trials: int, stai: float, model_parameters: tuple):
        # Task structure
        self.n_trials = n_trials
        self.n_choices = 2
        self.n_states = 2
        self.stai = stai
        
        # Transition probabilities
        # Assuming these are fixed for all models unless explicitly overridden
        self.trans_counts = np.array([[35, 15], [15, 35]]) 
        self.T = self.trans_counts / self.trans_counts.sum(axis=1, keepdims=True)
        
        # Choice probability sequences (for fitting, not directly used in simulation logic)
        self.p_choice_1 = np.zeros(n_trials)
        self.p_choice_2 = np.zeros(n_trials)
        
        # Value representations
        self.q_stage1 = np.zeros(self.n_choices)
        self.q_stage2 = 0.5 * np.ones((self.n_states, self.n_choices)) # Initialized to 0.5 for neutrality
        
        # Trial tracking
        self.trial = 0
        self.last_action1 = None
        self.last_action2 = None
        self.last_state = None
        self.last_reward = None
        
        # Initialize
        self.unpack_parameters(model_parameters)
        self.init_model()

    @abstractmethod
    def unpack_parameters(self, model_parameters: tuple) -> None:
        """Unpack model_parameters into named attributes."""
        pass

    def init_model(self) -> None:
        """Initialize model state. Override to set up additional variables."""
        pass

    def policy_stage1(self) -> np.ndarray:
        """Compute stage-1 action probabilities. Override to customize."""
        return self.softmax(self.q_stage1, self.beta)

    def policy_stage2(self, state: int) -> np.ndarray:
        """Compute stage-2 action probabilities. Override to customize."""
        return self.softmax(self.q_stage2[state], self.beta)

    def value_update(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        """Update values after observing outcome. Override to customize."""
        delta_2 = reward - self.q_stage2[state, action_2]
        self.q_stage2[state, action_2] += self.alpha * delta_2
        
        delta_1 = self.q_stage2[state, action_2] - self.q_stage1[action_1]
        self.q_stage1[action_1] += self.alpha * delta_1

    def pre_trial(self) -> None:
        """Called before each trial. Override to add computations."""
        pass

    def post_trial(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        """Called after each trial. Override to add computations."""
        self.last_action1 = action_1
        self.last_action2 = action_2
        self.last_state = state
        self.last_reward = reward

    def run_model(self, action_1, state, action_2, reward) -> float:
        """Run model over all trials for fitting. Not used in simulation."""
        for self.trial in range(self.n_trials):
            a1, s = int(action_1[self.trial]), int(state[self.trial])
            a2, r = int(action_2[self.trial]), float(reward[self.trial])
            
            self.pre_trial()
            self.p_choice_1[self.trial] = self.policy_stage1()[a1]
            self.p_choice_2[self.trial] = self.policy_stage2(s)[a2]
            self.value_update(a1, s, a2, r)
            self.post_trial(a1, s, a2, r)
        
        return self.compute_nll()
    
    def compute_nll(self) -> float:
        """Compute negative log-likelihood (for fitting, not simulation)."""
        eps = 1e-12
        return -(np.sum(np.log(self.p_choice_1 + eps)) + np.sum(np.log(self.p_choice_2 + eps)))
    
    def softmax(self, values: np.ndarray, beta: float) -> np.ndarray:
        """Softmax action selection."""
        centered = values - np.max(values) # For numerical stability
        exp_vals = np.exp(beta * centered)
        return exp_vals / np.sum(exp_vals)


class ParticipantModel3(CognitiveModelBase):
    """
    HYPOTHESIS: High anxiety increases "choice stickiness" or a repetition bias
    for the first-stage action. This means participants are more likely to repeat
    the spaceship choice they made on the previous trial, with the strength of
    this bias increasing with their STAI score.

    Parameter Bounds:
    -----------------
    alpha: [0, 1] (Learning rate)
    beta: [0, 10] (Inverse temperature for softmax choice)
    stickiness_stai_factor: [0, 5] (Factor by which STAI score influences stickiness bonus.
                                    A positive value means higher STAI increases stickiness.)
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.stickiness_stai_factor = model_parameters
        
    def init_model(self) -> None:
        # Initialize last_action1 to a value that signifies no previous action (e.g., -1)
        # This prevents stickiness from being applied on the very first trial.
        self.last_action1 = -1 

    def policy_stage1(self) -> np.ndarray:
        # Create a copy of the current Q-values for Stage 1 to apply the stickiness bonus
        q_prime_stage1 = np.copy(self.q_stage1)
        
        # Apply stickiness bonus only if a previous Stage 1 action exists
        if self.last_action1 != -1: 
            # The stickiness bonus is scaled by the STAI score and the stickiness factor.
            # This makes the previous choice more attractive.
            stickiness_bonus = self.stickiness_stai_factor * self.stai
            q_prime_stage1[self.last_action1] += stickiness_bonus
            
        # Compute action probabilities using softmax on the modified Q-values
        return self.softmax(q_prime_stage1, self.beta)

    # The value_update and post_trial methods use the default implementations
    # from CognitiveModelBase, where post_trial correctly updates self.last_action1.

# The `make_cognitive_model` function is for fitting and not directly used in simulation.
# cognitive_model3 = make_cognitive_model(ParticipantModel3)


def simulate_model(
    ModelClass,
    n_trials: int,
    stai: float,
    model_parameters: tuple,
    drift1: np.ndarray,
    drift2: np.ndarray,
    drift3: np.ndarray,
    drift4: np.ndarray,
    seed: int | None = None,
) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Simulate a two-step task trajectory from any current-template model class
    (i.e., a subclass of CognitiveModelBase like ParticipantModel1/2/3).

    Task structure:
      - Stage 1: choose action_1 in {0,1}
      - Transition: state in {0,1} sampled from model.T[action_1]
      - Stage 2: choose action_2 in {0,1} conditioned on state
      - Reward: sampled from drifting reward probabilities:
          state 0: [drift1[t], drift2[t]] for actions 0/1
          state 1: [drift3[t], drift4[t]] for actions 0/1

    Parameters
    ----------
    ModelClass : type
        A subclass of CognitiveModelBase (e.g., ParticipantModel3).
    n_trials : int
        Number of trials to simulate.
    stai : float
        Participant anxiety score; passed into the model constructor as self.stai.
    model_parameters : tuple
        Parameters expected by ModelClass.unpack_parameters(...).
    drift1, drift2, drift3, drift4 : np.ndarray (length n_trials)
        Trial-wise reward probabilities for the 4 (state, action) pairs.
    seed : int or None
        RNG seed.

    Returns
    -------
    stage1_choice : np.ndarray, shape (n_trials,)
    state2          : np.ndarray, shape (n_trials,)
    stage2_choice : np.ndarray, shape (n_trials,)
    reward        : np.ndarray, shape (n_trials,)
    """
    rng = np.random.default_rng(seed)

    # Instantiate model (will set up q-values, self.T, etc.)
    # Ensure stai is a float as expected by the constructor
    model = ModelClass(n_trials=n_trials, stai=float(stai), model_parameters=model_parameters)

    # Arrays to store simulated participant data
    stage1_choice = np.zeros(n_trials, dtype=int)
    state2 = np.zeros(n_trials, dtype=int)
    stage2_choice = np.zeros(n_trials, dtype=int)
    reward = np.zeros(n_trials, dtype=int)

    for t in range(n_trials):
        model.trial = t
        model.pre_trial()

        # --- Stage 1 choice ---
        p1 = model.policy_stage1()
        # Safety normalize in case an override returns tiny numerical drift
        p1 = np.clip(p1, 1e-12, 1.0)
        p1 = p1 / np.sum(p1)
        a1 = int(rng.choice([0, 1], p=p1))

        # --- Transition ---
        pT = model.T[a1]
        pT = np.clip(pT, 1e-12, 1.0)
        pT = pT / np.sum(pT)
        s = int(rng.choice([0, 1], p=pT))

        # --- Stage 2 choice ---
        p2 = model.policy_stage2(s)
        p2 = np.clip(p2, 1e-12, 1.0)
        p2 = p2 / np.sum(p2)
        a2 = int(rng.choice([0, 1], p=p2))

        # --- Reward from drifting probabilities ---
        # state 0 -> (drift1, drift2); state 1 -> (drift3, drift4)
        if s == 0:
            pr = float(drift1[t]) if a2 == 0 else float(drift2[t])
        else:
            pr = float(drift3[t]) if a2 == 0 else float(drift4[t])

        r = int(rng.random() < pr) # Sample reward (0 or 1)

        # (Optional) store likelihoods if you want (not required for simulation)
        # model.p_choice_1[t] = p1[a1]
        # model.p_choice_2[t] = p2[a2]

        # --- Learning update + bookkeeping ---
        model.value_update(a1, s, a2, float(r))
        model.post_trial(a1, s, a2, float(r))

        # Store simulated data
        stage1_choice[t] = a1
        state2[t] = s
        stage2_choice[t] = a2
        reward[t] = r

    return stage1_choice, state2, stage2_choice, reward
```