```python
class ParticipantModel1(CognitiveModelBase):
    """
    [HYPOTHESIS: Anxiety-Impaired Model-Based Control]
    This model implements a hybrid Model-Based / Model-Free reinforcement learning agent.
    It hypothesizes that anxiety consumes working memory resources required for 
    model-based planning (calculating expected values based on transition probabilities). 
    Therefore, the weight (w) assigned to the model-based value estimates decreases 
    as anxiety (stai) increases, shifting control towards the model-free system.

    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    w_max: [0, 1] (Maximum model-based weight for a person with 0 anxiety)
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.w_max = model_parameters

    def policy_stage1(self) -> np.ndarray:
        # 1. Calculate Model-Based Values
        # Q_MB(a1) = Sum_s [ P(s|a1) * max_a2 Q_stage2(s, a2) ]
        # self.T is shape (n_choices_stage1, n_states)
        # self.q_stage2 is shape (n_states, n_choices_stage2)
        
        max_q2 = np.max(self.q_stage2, axis=1) # Max value achievable in each state
        q_mb = np.dot(self.T, max_q2)          # Expected value of each stage 1 action
        
        # 2. Calculate Model-Free Values
        q_mf = self.q_stage1
        
        # 3. Determine Mixing Weight based on Anxiety
        # Higher anxiety -> Lower w (less Model-Based)
        # We clamp w to be non-negative.
        w_eff = max(0.0, self.w_max * (1.0 - self.stai))
        
        # 4. Combine
        q_net = w_eff * q_mb + (1.0 - w_eff) * q_mf
        
        return self.softmax(q_net, self.beta)

cognitive_model1 = make_cognitive_model(ParticipantModel1)


class ParticipantModel2(CognitiveModelBase):
    """
    [HYPOTHESIS: Anxiety-Driven Negativity Bias]
    This model hypothesizes that anxious individuals are hyper-sensitive to negative 
    prediction errors (outcomes that are worse than expected). The learning rate 
    is asymmetrically boosted by anxiety when the prediction error is negative, 
    leading to faster learning from disappointments or losses compared to gains.

    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    neg_bias: [0, 5] (Multiplier for anxiety's effect on negative learning rate)
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.neg_bias = model_parameters

    def value_update(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        # Stage 2 Update
        delta_2 = reward - self.q_stage2[state, action_2]
        
        # Determine effective alpha for Stage 2
        if delta_2 < 0:
            # Boost learning rate for negative PE based on anxiety
            alpha_2 = self.alpha * (1.0 + self.neg_bias * self.stai)
            # Cap alpha at 1.0 to prevent instability
            alpha_2 = min(1.0, alpha_2)
        else:
            alpha_2 = self.alpha
            
        self.q_stage2[state, action_2] += alpha_2 * delta_2
        
        # Stage 1 Update
        # Note: Using the updated Q2 value for TD(0) update of Q1
        delta_1 = self.q_stage2[state, action_2] - self.q_stage1[action_1]
        
        # Determine effective alpha for Stage 1
        if delta_1 < 0:
            alpha_1 = self.alpha * (1.0 + self.neg_bias * self.stai)
            alpha_1 = min(1.0, alpha_1)
        else:
            alpha_1 = self.alpha
            
        self.q_stage1[action_1] += alpha_1 * delta_1

cognitive_model2 = make_cognitive_model(ParticipantModel2)


class ParticipantModel3(CognitiveModelBase):
    """
    [HYPOTHESIS: Anxiety-Induced Memory Decay]
    This model hypothesizes that anxiety creates cognitive interference, leading to 
    faster decay (forgetting) of learned values. The Q-values for both stages 
    decay towards a neutral prior (0.5) at a rate proportional to the participant's 
    anxiety level. This reflects an inability to maintain stable value representations 
    over time due to anxious rumination or distraction.

    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    decay_scale: [0, 1] (Scaling factor for anxiety-driven decay rate)
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.decay_scale = model_parameters

    def post_trial(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        # Call base method to store last actions
        super().post_trial(action_1, state, action_2, reward)
        
        # Calculate decay rate based on anxiety
        # Rate is bounded between 0 and 1
        decay_rate = self.decay_scale * self.stai
        decay_rate = min(1.0, max(0.0, decay_rate))
        
        # Decay Stage 1 values towards 0.5
        self.q_stage1 = (1.0 - decay_rate) * self.q_stage1 + decay_rate * 0.5
        
        # Decay Stage 2 values towards 0.5
        self.q_stage2 = (1.0 - decay_rate) * self.q_stage2 + decay_rate * 0.5

cognitive_model3 = make_cognitive_model(ParticipantModel3)
```