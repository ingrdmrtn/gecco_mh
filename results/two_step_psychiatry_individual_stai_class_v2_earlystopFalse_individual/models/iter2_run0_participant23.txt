Here are three new cognitive models that hypothesize different mechanisms for how anxiety (STAI) modulates decision-making in this task.

### Model 1: Anxiety-Modulated Memory Decay
This model tests the hypothesis that anxiety consumes cognitive resources (e.g., working memory capacity), leading to faster forgetting of the values of options that are not currently being chosen.

```python
class ParticipantModel1(CognitiveModelBase):
    """
    [HYPOTHESIS: Anxiety-Modulated Memory Decay]
    This model hypothesizes that anxiety accelerates the decay (forgetting) of value 
    representations for unchosen options. High anxiety individuals may struggle to 
    maintain value estimates for options they are not actively selecting.
    
    The decay rate is modulated by STAI: 
    decay = decay_base + (decay_anx * stai).
    
    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    decay_base: [0, 1]
    decay_anx: [0, 1]
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.decay_base, self.decay_anx = model_parameters

    def value_update(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        # Calculate decay rate based on anxiety
        decay = self.decay_base + (self.decay_anx * self.stai)
        decay = np.clip(decay, 0.0, 1.0)

        # Standard update for chosen options (Stage 2)
        delta_2 = reward - self.q_stage2[state, action_2]
        self.q_stage2[state, action_2] += self.alpha * delta_2
        
        # Standard update for chosen options (Stage 1)
        delta_1 = self.q_stage2[state, action_2] - self.q_stage1[action_1]
        self.q_stage1[action_1] += self.alpha * delta_1
        
        # Decay unchosen options
        # Stage 1
        unchosen_1 = 1 - action_1
        self.q_stage1[unchosen_1] *= (1.0 - decay)
        
        # Stage 2 (only in the visited state)
        unchosen_2 = 1 - action_2
        self.q_stage2[state, unchosen_2] *= (1.0 - decay)

cognitive_model1 = make_cognitive_model(ParticipantModel1)
```

### Model 2: Anxiety-Modulated Eligibility Trace
This model focuses on credit assignment. It hypothesizes that anxiety affects the "eligibility trace" ($\lambda$), which determines how much the final reward directly reinforces the first-stage choice, bypassing the model-based or intermediate state value.

```python
class ParticipantModel2(CognitiveModelBase):
    """
    [HYPOTHESIS: Anxiety-Modulated Eligibility Trace]
    This model hypothesizes that anxiety alters the credit assignment process between stages.
    It modulates the eligibility trace (lambda), which controls how much the final outcome (Reward) 
    directly updates the Stage 1 choice value, effectively blending Model-Free TD(1) and TD(0) updates.
    
    Lambda = lambda_base + (lambda_anx * stai).
    
    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    lambda_base: [0, 1]
    lambda_anx: [-1, 1] (Allows anxiety to either increase or decrease the trace)
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.lambda_base, self.lambda_anx = model_parameters

    def value_update(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        # Calculate lambda based on anxiety
        lam = self.lambda_base + (self.lambda_anx * self.stai)
        lam = np.clip(lam, 0.0, 1.0)
        
        # Stage 2 Prediction Error
        delta_2 = reward - self.q_stage2[state, action_2]
        
        # Update Stage 2
        self.q_stage2[state, action_2] += self.alpha * delta_2
        
        # Stage 1 Update
        # Part 1: TD(0) update (bootstrapping from Stage 2 value)
        delta_1 = self.q_stage2[state, action_2] - self.q_stage1[action_1]
        self.q_stage1[action_1] += self.alpha * delta_1
        
        # Part 2: Eligibility Trace update (direct reinforcement from Reward via delta_2)
        # This adds the "Model-Free" direct connection from Outcome to Stage 1 Choice
        self.q_stage1[action_1] += self.alpha * lam * delta_2

cognitive_model2 = make_cognitive_model(ParticipantModel2)
```

### Model 3: Differential Stage Learning
This model hypothesizes that anxiety differentially affects learning at different levels of the decision hierarchy. Specifically, it allows the learning rate for the abstract Stage 1 decision to differ from the reactive Stage 2 decision as a function of anxiety.

```python
class ParticipantModel3(CognitiveModelBase):
    """
    [HYPOTHESIS: Differential Stage Learning]
    Anxiety may differentially affect learning from immediate outcomes (Stage 2) versus 
    distal predictions (Stage 1). This model allows the Stage 1 learning rate to vary 
    as a function of anxiety, while the Stage 2 rate remains fixed (or distinct).
    
    alpha_1 = alpha_1_base + (alpha_1_anx * stai)
    alpha_2 is the base learning rate.
    
    Parameter Bounds:
    -----------------
    alpha_2: [0, 1] (Base learning rate for Stage 2)
    beta: [0, 10]
    alpha_1_base: [0, 1]
    alpha_1_anx: [-1, 1]
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha_2, self.beta, self.alpha_1_base, self.alpha_1_anx = model_parameters

    def value_update(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        # Calculate Stage 1 specific learning rate
        alpha_1 = self.alpha_1_base + (self.alpha_1_anx * self.stai)
        alpha_1 = np.clip(alpha_1, 0.0, 1.0)
        
        # Update Stage 2 (using alpha_2)
        delta_2 = reward - self.q_stage2[state, action_2]
        self.q_stage2[state, action_2] += self.alpha_2 * delta_2
        
        # Update Stage 1 (using modulated alpha_1)
        delta_1 = self.q_stage2[state, action_2] - self.q_stage1[action_1]
        self.q_stage1[action_1] += alpha_1 * delta_1

cognitive_model3 = make_cognitive_model(ParticipantModel3)
```