Here are three new cognitive models that hypothesize different mechanisms for how anxiety (STAI) modulates decision-making in this task.

```python
class ParticipantModel1(CognitiveModelBase):
    """
    HYPOTHESIS: Anxiety-Driven Reactive Switching (Lose-Shift)
    
    This model hypothesizes that high anxiety leads to a "flight" response after 
    negative outcomes. Specifically, if the participant receives 0 coins (loss), 
    anxiety increases the probability of switching to the other spaceship on the 
    next trial. This is a specific modulation of the "Lose-Shift" heuristic.
    
    Switch Bonus = switch_factor * stai * (last_reward == 0)
    This bonus is added to the unchosen option's value during selection.

    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    switch_factor: [0, 5]
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.switch_factor = model_parameters

    def policy_stage1(self) -> np.ndarray:
        values = self.q_stage1.copy()
        
        # Apply switching bonus if last trial was a loss (0 coins)
        if self.last_reward is not None and self.last_reward == 0.0:
            last_a1 = int(self.last_action1)
            other_a1 = 1 - last_a1
            
            # The urge to switch is proportional to anxiety
            bonus = self.switch_factor * self.stai
            values[other_a1] += bonus
            
        return self.softmax(values, self.beta)

cognitive_model1 = make_cognitive_model(ParticipantModel1)


class ParticipantModel2(CognitiveModelBase):
    """
    HYPOTHESIS: Anxiety-Driven Surprise Aversion
    
    This model hypothesizes that anxious individuals find "rare" or unexpected 
    transitions aversive. They penalize the spaceship choice that led to a rare 
    transition (e.g., Spaceship A -> Planet Y), effectively reducing its value 
    regardless of the actual reward outcome.
    
    Penalty = surprise_penalty * stai
    This penalty is subtracted from the Stage 1 target value when a rare transition occurs.

    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta: [0, 10]
    surprise_penalty: [0, 2]
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta, self.surprise_penalty = model_parameters

    def value_update(self, action_1: int, state: int, action_2: int, reward: float) -> None:
        # Standard Stage 2 update
        delta_2 = reward - self.q_stage2[state, action_2]
        self.q_stage2[state, action_2] += self.alpha * delta_2
        
        # Determine if transition was rare
        # Based on trans_counts [[35, 15], [15, 35]]:
        # Action 0 (A) -> State 0 (X) is Common; -> State 1 (Y) is Rare
        # Action 1 (U) -> State 1 (Y) is Common; -> State 0 (X) is Rare
        is_rare = (action_1 == 0 and state == 1) or (action_1 == 1 and state == 0)
        
        # Calculate anxiety-driven penalty
        penalty = 0.0
        if is_rare:
            penalty = self.surprise_penalty * self.stai
            
        # Stage 1 update: The target value is the Q-value of the second stage minus the penalty
        target_val = self.q_stage2[state, action_2] - penalty
        delta_1 = target_val - self.q_stage1[action_1]
        self.q_stage1[action_1] += self.alpha * delta_1

cognitive_model2 = make_cognitive_model(ParticipantModel2)


class ParticipantModel3(CognitiveModelBase):
    """
    HYPOTHESIS: Anxiety-Induced Decision Noise
    
    This model hypothesizes that high anxiety interferes with cognitive processing,
    leading to noisier, less deterministic choices (choking under pressure). 
    This is modeled by scaling down the inverse temperature (beta) parameter 
    as anxiety increases.
    
    Effective Beta = beta_base / (1 + noise_factor * stai)

    Parameter Bounds:
    -----------------
    alpha: [0, 1]
    beta_base: [0, 10]
    noise_factor: [0, 10]
    """

    def unpack_parameters(self, model_parameters: tuple) -> None:
        self.alpha, self.beta_base, self.noise_factor = model_parameters
        
    def init_model(self) -> None:
        # Calculate effective beta once since STAI is constant for the participant
        # Higher anxiety -> Higher denominator -> Lower effective beta -> More random choices
        self.eff_beta = self.beta_base / (1.0 + self.noise_factor * self.stai)

    def policy_stage1(self) -> np.ndarray:
        return self.softmax(self.q_stage1, self.eff_beta)

    def policy_stage2(self, state: int) -> np.ndarray:
        return self.softmax(self.q_stage2[state], self.eff_beta)

cognitive_model3 = make_cognitive_model(ParticipantModel3)
```